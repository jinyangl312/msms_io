import tqdm
import os
import struct
from pathlib import Path


def pf2_loader_unit(path):
    '''
    Return a generator for spectra from .pf2 binary file @path generated by pFind 3
    '''

    with open(path, "rb") as f:
        if "_HCDFT" in os.path.basename(path):
            spec_title = os.path.basename(path).split("_HCDFT")[0]
        else:
            spec_title = os.path.basename(path)[:-10]
        nSpec, lenTitle = struct.unpack("2i", f.read(8))
        pf2title = struct.unpack("%ds" % lenTitle, f.read(lenTitle))

        for _ in tqdm.tqdm(range(nSpec)):
            scan_no, = struct.unpack("i", f.read(4))
            nPeak, = struct.unpack("i", f.read(4))
            peaks = []
            mz_int = struct.unpack(str(nPeak*2)+"d", f.read(nPeak*2*8))
            for i_peak in range(nPeak):
                mz = mz_int[i_peak*2]
                inten = mz_int[i_peak*2 + 1]
                peaks.append((mz, inten))

            max_inten = 0
            if len(peaks) != 0:
                max_inten = max(peaks, key=lambda x: x[1])[1]

            nMix, = struct.unpack("i", f.read(4))
            for i_mix in range(nMix):
                precursor, = struct.unpack("d", f.read(8))
                nCharge, = struct.unpack("i", f.read(4))
                specname = f"{spec_title}.{scan_no}.{scan_no}.{nCharge}.{i_mix}.dta"
                spec_info = {"TITLE": specname, "CHARGE": nCharge,
                             "PEPMASS": precursor, "MAX_INTEN": max_inten}
                yield spec_info, peaks


def pf2_loader(path_list):
    '''
    Return a generator for spectra from all .pf2 binary file in @path_list generated by pFind 3
    '''

    if not isinstance(path_list, list):
        path_list = Path(path_list)
        assert path_list.is_dir()
        path_list = path_list.glob('*.pf2')

    for path in path_list:
        for spec_info, peaks in pf2_loader_unit(path):
            yield spec_info, peaks


def load_pf2_header(path):
    '''
    Return the header of .pf2 binary file @path
    '''
    with open(path, "rb") as f:
        nSpec, lenTitle = struct.unpack("2i", f.read(8))
        pf2title = struct.unpack("%ds" % lenTitle, f.read(lenTitle))[0]
    return nSpec, lenTitle, pf2title


def load_whole_pf2(path_list):
    '''
    Return a dict for all spectra from all .pf2 binary files in @path_list
    '''

    if not isinstance(path_list, list):
        path_list = Path(path_list)
        assert path_list.is_dir()
        path_list = path_list.glob('*.pf2')

    mpSpec = {}
    for path in tqdm.tqdm(path_list):
        for spec_info, peaks in pf2_loader_unit(path):
            mpSpec[spec_info["TITLE"]] = (spec_info, peaks)
    return mpSpec


def pf2_filter_by_title_dict(src_path, dest_path, nSpec_new, title_dict):
    '''
    Read pf2 file @src_path and keep @nSpec_new specs in @title_dict and write it to @dest_path
    TODO: Where was is used? I forgot...
    '''

    fwrite = open(dest_path, "wb")
    with open(src_path, "rb") as fread:
        if "_HCDFT" in os.path.basename(src_path):
            spec_title = os.path.basename(src_path).split("_HCDFT")[0]
        else:
            spec_title = os.path.basename(src_path)[:-10]
        nSpec, lenTitle = struct.unpack("2i", fread.read(8))
        fwrite.write(struct.pack("2i", nSpec_new, lenTitle))
        fwrite.write(fread.read(lenTitle))

        for _ in tqdm.tqdm(range(nSpec)):
            scan_no, = struct.unpack("i", fread.read(4))
            nPeak, = struct.unpack("i", fread.read(4))

            mz_int_b = fread.read(nPeak*2*8)

            nMix, = struct.unpack("i", fread.read(4))
            precursor_list = []
            nCharge_list = []
            for i_mix in range(nMix):
                precursor, = struct.unpack("d", fread.read(8))
                nCharge, = struct.unpack("i", fread.read(4))
                specname = f"{spec_title}.{scan_no}.{scan_no}.{nCharge}.{i_mix}.dta"
                if specname in title_dict:
                    precursor_list.append(precursor)
                    nCharge_list.append(nCharge)

            if len(precursor_list) == 0:
                continue

            fwrite.write(struct.pack("i", scan_no))
            fwrite.write(struct.pack("i", nPeak))
            fwrite.write(mz_int_b)
            fwrite.write(struct.pack("i", len(precursor_list)))
            for precursor, nCharge in zip(precursor_list, nCharge_list):
                fwrite.write(struct.pack("d", precursor))
                fwrite.write(struct.pack("i", nCharge))
    fwrite.close()
