from ast import For
from http.client import CONTINUE
import tqdm
import os
import struct
import re
from pathlib import Path
import numpy as np
from peaks_scripts.sequence_set import SequentialSet


def pf2_loader_unit(path):
    '''
    Return a generator for spectra from .pf2 binary file generated by pFind 3
    '''

    with open(path, "rb") as f:
        if "_HCDFT" in os.path.basename(path):
            spec_title = os.path.basename(path).split("_HCDFT")[0]
        else:
            spec_title = os.path.basename(path)[:-10]
        nSpec, lenTitle = struct.unpack("2i", f.read(8))
        pf2title = struct.unpack("%ds" % lenTitle, f.read(lenTitle))

        #mpSpec = {}
        for _ in tqdm.tqdm(range(nSpec)):
            scan_no, = struct.unpack("i", f.read(4))
            nPeak, = struct.unpack("i", f.read(4))
            peaks = []
            mz_int = struct.unpack(str(nPeak*2)+"d", f.read(nPeak*2*8))
            for i_peak in range(nPeak):
                mz = mz_int[i_peak*2]
                inten = mz_int[i_peak*2 + 1]
                peaks.append((mz, inten))

            max_inten = 0
            if len(peaks) != 0:
                max_inten = max(peaks, key=lambda x: x[1])[1]

            nMix, = struct.unpack("i", f.read(4))
            for i_mix in range(nMix):
                precursor, = struct.unpack("d", f.read(8))
                nCharge, = struct.unpack("i", f.read(4))
                specname = f"{spec_title}.{scan_no}.{scan_no}.{nCharge}.{i_mix}.dta"
                spec_info = {"TITLE": specname, "CHARGE": nCharge,
                             "PEPMASS": precursor, "MAX_INTEN": max_inten}
                yield spec_info, peaks


def pf2_filter_by_title_dict(src_path, dest_path, nSpec_new, title_dict):
    '''
    Return a generator for spectra from .pf2 binary file generated by pFind 3
    '''

    fwrite = open(dest_path, "wb")
    with open(src_path, "rb") as fread:
        if "_HCDFT" in os.path.basename(src_path):
            spec_title = os.path.basename(src_path).split("_HCDFT")[0]
        else:
            spec_title = os.path.basename(src_path)[:-10]
        nSpec, lenTitle = struct.unpack("2i", fread.read(8))
        fwrite.write(struct.pack("2i", nSpec_new, lenTitle))
        fwrite.write(fread.read(lenTitle))

        #mpSpec = {}
        for _ in tqdm.tqdm(range(nSpec)):
            scan_no, = struct.unpack("i", fread.read(4))
            nPeak, = struct.unpack("i", fread.read(4))

            mz_int_b = fread.read(nPeak*2*8)

            nMix, = struct.unpack("i", fread.read(4))
            precursor_list = []
            nCharge_list = []
            for i_mix in range(nMix):
                precursor, = struct.unpack("d", fread.read(8))
                nCharge, = struct.unpack("i", fread.read(4))
                specname = f"{spec_title}.{scan_no}.{scan_no}.{nCharge}.{i_mix}.dta"
                if specname in title_dict:
                    precursor_list.append(precursor)
                    nCharge_list.append(nCharge)

            if len(precursor_list) == 0:
                continue

            fwrite.write(struct.pack("i", scan_no))
            fwrite.write(struct.pack("i", nPeak))
            fwrite.write(mz_int_b)
            fwrite.write(struct.pack("i", len(precursor_list)))
            for precursor, nCharge in zip(precursor_list, nCharge_list):
                fwrite.write(struct.pack("d", precursor))
                fwrite.write(struct.pack("i", nCharge))
    fwrite.close()


def pf2_loader(path_list):
    '''
    Return a generator for spectra from .pf2 binary file generated by pFind 3
    '''

    if not isinstance(path_list, list):
        path_list = Path(path_list)
        assert path_list.is_dir()
        path_list = path_list.glob('*.pf2')

    for path in path_list:
        for spec_info, peaks in pf2_loader_unit(path):
            yield spec_info, peaks


def load_pf2_header(path):
    with open(path, "rb") as f:
        nSpec, lenTitle = struct.unpack("2i", f.read(8))
        pf2title = struct.unpack("%ds" % lenTitle, f.read(lenTitle))[0]
    return nSpec, lenTitle, pf2title


def load_whole_pf2(path_list):
    '''
    Return a dict for all experimental spectra from .pf2 binary file
    generated by pFind 3
    '''

    if not isinstance(path_list, list):
        path_list = Path(path_list)
        assert path_list.is_dir()
        path_list = path_list.glob('*.pf2')

    mpSpec = {}
    for path in tqdm.tqdm(path_list):
        for spec_info, peaks in pf2_loader_unit(path):
            mpSpec[spec_info["TITLE"]] = (spec_info, peaks)
    return mpSpec


def mgf_loader_unit(path, transform_peaks=True):
    '''
    Return a generator for experimental spectra from .mgf text file
    By default if @transform_peaks=True, mz and intensity arrays will be converted to float; otherwise they will be kept as a string.
    '''

    with open(path, "r") as f:
        while True:
            # Go to the next "BEGIN IONS"
            line = f.readline()
            if not line:  # EOF
                break
            while not "BEGIN IONS" in line:
                line = f.readline()
                if not line:  # EOF
                    break
            if not line:
                break

            # Parse spec headers
            line = f.readline()
            spec_info = dict()
            while "=" in line:
                line = re.split("=|\n", line)
                spec_info[line[0]] = line[1]
                line = f.readline()

            # Parse mz and intensity arrays
            if transform_peaks:
                peaks = []
                while not 'END IONS' in line:
                    line = re.split("\s|\n", line)
                    peaks.append((float(line[0]), float(line[1])))
                    line = f.readline()
            else:
                peaks = ""
                while not 'END IONS' in line:
                    peaks += line
                    line = f.readline()
            yield spec_info, peaks


def mgf_loader(path_list, transform_peaks=True):
    '''
    Return a generator for experimental spectra from .mgf text file
    By default if @transform_peaks=True, mz and intensity arrays will be converted to float; otherwise they will be kept as a string.
    '''

    if not isinstance(path_list, list):
        path_list = Path(path_list)
        assert path_list.is_dir()
        path_list = path_list.glob('*.mgf')

    for path in tqdm.tqdm(path_list):
        for spec_info, peaks in mgf_loader_unit(path):
            yield spec_info, peaks


def load_whole_mgf_unit(path, transform_peaks=True):
    '''
    Return a dict for all experimental spectra from .mgf text file
    By default if @transform_peaks=True, mz and intensity arrays will be converted to float; otherwise they will be kept as a string.
    '''

    if os.path.exists(f"{path}{'_t' if transform_peaks else '_k'}.npy"):
        return np.load(f"{path}{'_t' if transform_peaks else '_k'}.npy", allow_pickle=True).item()

    mpSpec = {}
    for spec_info, peaks in mgf_loader_unit(path, transform_peaks):
        mpSpec[spec_info["TITLE"]] = (spec_info, peaks)
    np.save(f"{path}{'_t' if transform_peaks else '_k'}.npy", mpSpec)
    return mpSpec


def load_whole_mgf(path_list, transform_peaks=True):
    '''
    Return a dict for all experimental spectra from .mgf text file
    By default if @transform_peaks=True, mz and intensity arrays will be converted to float; otherwise they will be kept as a string.
    '''

    if not isinstance(path_list, list):
        path_list = Path(path_list)
        assert path_list.is_dir()
        path_list = path_list.glob('*.mgf')

    mpSpec = {}
    for path in tqdm.tqdm(path_list):
        mpSpec.update(load_whole_mgf_unit(path, transform_peaks))
    return mpSpec


class get_mgf_headers:
    def __init__(self, path_list, relative_error=20e-6, mixed_spectra=True):
        '''
        Return a list of all headers contained in mgf.
        Can be used to check precursor evidence for results.
        '''
        # May add temp here!

        
        path_list = Path(path_list)
        assert path_list.is_dir()

        # Can't pickle local object 'SequentialSet.set_relative_error.<locals>.<lambda>'
        # if os.path.exists(f"{path_list}/scan_headers_dict_{relative_error}{mixed_spectra}.npy"):
        #     print('Loading from tmp files...')
        #     self.PSM_headers_dict = np.load(f"{path_list}/PSM_headers_dict_{relative_error}{mixed_spectra}.npy", allow_pickle=True).item()
        #     self.scan_charge_headers_dict = np.load(f"{path_list}/scan_charge_headers_dict_{relative_error}{mixed_spectra}.npy", allow_pickle=True).item()
        #     self.scan_headers_dict = np.load(f"{path_list}/scan_headers_dict_{relative_error}{mixed_spectra}.npy", allow_pickle=True).item()
        #     print(len(self.PSM_headers_dict))
        #     print(len(self.scan_charge_headers_dict))
        #     print(len(self.scan_headers_dict))
        #     return

        file_path_list = path_list.glob('*.mgf')

        self.mpSpec = {}
        for path in tqdm.tqdm(file_path_list, desc='Loading'):
            mpSpec_tmp = load_whole_mgf_unit(path, transform_peaks=False)
            mpSpec_tmp = {k: v[0] for k, v in mpSpec_tmp.items()}
            self.mpSpec.update(mpSpec_tmp)

        # Build up precursor info dict
        self.scan_headers_dict = dict()
        self.scan_charge_headers_dict = dict()
        self.PSM_headers_dict = dict()
        if mixed_spectra:
            for header in self.mpSpec.values():
                self.PSM_headers_dict[header["TITLE"]] = [
                    float(header["PEPMASS"])]

                scan_id = re.search(
                    ".*?\.\d+\.\d+(?=\.\d+\.\d+\.dta)", header["TITLE"]).group()
                if scan_id in self.scan_headers_dict:
                    self.scan_headers_dict[scan_id].append(
                        float(header["PEPMASS"]))
                else:
                    self.scan_headers_dict[scan_id] = [
                        float(header["PEPMASS"])]

                scan_charge_id = re.search(
                    ".*?\.\d+\.\d+\.\d+(?=\.\d+\.dta)", header["TITLE"]).group()
                if scan_charge_id in self.scan_charge_headers_dict:
                    self.scan_charge_headers_dict[scan_charge_id].append(
                        float(header["PEPMASS"]))
                else:
                    self.scan_charge_headers_dict[scan_charge_id] = [
                        float(header["PEPMASS"])]
        else:
            for header in self.mpSpec.values():
                self.PSM_headers_dict[header["TITLE"]] = [
                    float(header["PEPMASS"])]

                scan_id = re.search(
                    ".*?\.\d+\.\d+(?=\.\d+\.dta)", header["TITLE"]).group()
                if scan_id in self.scan_headers_dict:
                    self.scan_headers_dict[scan_id].append(
                        float(header["PEPMASS"]))
                else:
                    self.scan_headers_dict[scan_id] = [
                        float(header["PEPMASS"])]

                scan_charge_id = re.search(
                    ".*?\.\d+\.\d+\.\d+(?=\.dta)", header["TITLE"]).group()
                if scan_charge_id in self.scan_charge_headers_dict:
                    self.scan_charge_headers_dict[scan_charge_id].append(
                        float(header["PEPMASS"]))
                else:
                    self.scan_charge_headers_dict[scan_charge_id] = [
                        float(header["PEPMASS"])]
        print('Total PSMs:', len(self.PSM_headers_dict))
        print('Total charged scans:', len(self.scan_charge_headers_dict))
        print('Total scans:', len(self.scan_headers_dict))

        for k, v in self.PSM_headers_dict.items():
            self.PSM_headers_dict[k] = SequentialSet(v)
            self.PSM_headers_dict[k].set_relative_error(relative_error)
        for k, v in self.scan_headers_dict.items():
            self.scan_headers_dict[k] = SequentialSet(v)
            self.scan_headers_dict[k].set_relative_error(relative_error)
        for k, v in self.scan_charge_headers_dict.items():
            self.scan_charge_headers_dict[k] = SequentialSet(v)
            self.scan_charge_headers_dict[k].set_relative_error(relative_error)
            
        # np.save(f"{path_list}/PSM_headers_dict_{relative_error}{mixed_spectra}.npy", self.PSM_headers_dict)
        # np.save(f"{path_list}/scan_charge_headers_dict_{relative_error}{mixed_spectra}.npy", self.scan_charge_headers_dict)
        # np.save(f"{path_list}/scan_headers_dict_{relative_error}{mixed_spectra}.npy", self.scan_headers_dict)
        return

    def __enter__(self):
        return self

    def __exit__(self, exception_type, exception_value, traceback):
        return


def ms1_loader_unit(path, transform_peaks=True):
    '''
    Return a generator from .ms1 text file
    By default if @transform_peaks=True, mz and intensity arrays will be
    converted to float; otherwise they will be kept as string.
    '''

    with open(path, "r") as f:
        line = f.readline()
        # Go to the next line starts with S
        if not line:  # EOF
            return
        while not line[0] == "S":
            line = f.readline()
            if not line:  # EOF
                break
        while True:
            if not line:
                return

            # Parse headers
            spec_info = dict()
            spec_info["scan_no"] = re.split("\t|\n", line)[1]
            line = f.readline()
            while line[0] == "I":
                line = re.split("\t|\n", line)
                spec_info[line[1]] = line[2]
                line = f.readline()

            # Parse mz and intensity arrays
            if transform_peaks:
                peaks = []
                for _ in range(int(spec_info["NumberOfPeaks"])):
                    line = re.split("\s|\n", line)
                    peaks.append((float(line[0]), float(line[1])))
                    line = f.readline()
            else:
                peaks = ""
                for _ in range(int(spec_info["NumberOfPeaks"])):
                    peaks += line
                    line = f.readline()
            yield spec_info, peaks


def load_whole_ms1_unit(path, transform_peaks=True):
    '''
    Return a dict for all experimental spectra from .mgf text file
    By default if @transform_peaks=True, mz and intensity arrays will be converted to float; otherwise they will be kept as a string.
    '''

    if os.path.exists(f"{path}{'_t' if transform_peaks else '_k'}.npy"):
        return np.load(f"{path}{'_t' if transform_peaks else '_k'}.npy", allow_pickle=True).item()

    mpSpec = {}
    for spec_info, peaks in ms1_loader_unit(path, transform_peaks):
        mpSpec[spec_info["scan_no"]] = (spec_info, peaks)
    np.save(f"{path}{'_t' if transform_peaks else '_k'}.npy", mpSpec)
    return mpSpec


class load_whole_ms1:
    def __init__(self, path_list, relative_error=20e-6, transform_peaks=True):
        '''
        Return a dict for all experimental spectra from .mgf text file
        By default if @transform_peaks=True, mz and intensity arrays will be converted to float; otherwise they will be kept as a string.
        '''

        if not isinstance(path_list, list):
            path_list = Path(path_list)
            assert path_list.is_dir()
            path_list = path_list.glob('*.ms1')

        self.mpSpec = {}
        for path in tqdm.tqdm(path_list, desc='Loading'):
            self.mpSpec[Path(path).stem] = load_whole_ms1_unit(
                path, transform_peaks)

        for _, ms1_unit_dict in tqdm.tqdm(self.mpSpec.items(), desc='Processing'):
            for scan_no, ms1_spec in ms1_unit_dict.items():
                ms1_unit_dict[scan_no] = SequentialSet(
                    np.array(ms1_spec[1])[:, 0])
                ms1_unit_dict[scan_no].set_relative_error(relative_error)
        return

    def __enter__(self):
        return self

    def __exit__(self, exception_type, exception_value, traceback):
        return
