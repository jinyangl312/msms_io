import tqdm
import os
import struct
import re

def load_whole_pf2(path_list):
    '''
    Return a dict for all experimental spectra from .pf2 binary file generated by pFind
    '''

    for path in path_list:
        with open(path, "rb") as f:
            spec_title = os.path.basename(path)[:-10]
            nSpec, lenTitle = struct.unpack("2i", f.read(8))
            pf2title = struct.unpack("%ds" %lenTitle, f.read(lenTitle))
            
            mpSpec = {}    
            for _ in tqdm.tqdm(range(nSpec)):
                scan_no, = struct.unpack("i",f.read(4))
                nPeak, = struct.unpack("i", f.read(4))
                peaks = []
                mz_int = struct.unpack(str(nPeak*2)+"d", f.read(nPeak*2*8))
                for i_peak in range(nPeak):
                    mz = mz_int[i_peak*2]
                    inten = mz_int[i_peak*2 + 1]
                    peaks.append( (mz, inten) )
                
                max_inten=0
                if len(peaks)!=0:
                    max_inten=max(peaks,key=lambda x:x[1])[1]
                
                nMix, = struct.unpack("i", f.read(4))
                nMaxCharge = 0
                for i_mix in range(nMix):
                    precursor, = struct.unpack("d", f.read(8))
                    nCharge, = struct.unpack("i", f.read(4))
                    if nCharge > nMaxCharge: nMaxCharge = nCharge
                    specname = f"{spec_title}.{scan_no}.{scan_no}.{nCharge}.{i_mix}.dta"
                    spec_info = (specname, nCharge, precursor, max_inten)
                    mpSpec[specname] = [spec_info, peaks]
            f.close()    
            yield pf2title, mpSpec

def pf2_loader(path_list):
    '''
    Return a generator for spectra from .pf2 binary file generated by pFind
    '''
    for path in path_list:
        with open(path, "rb") as f:
            spec_title = os.path.basename(path)[:-10]
            nSpec, lenTitle = struct.unpack("2i", f.read(8))
            pf2title = struct.unpack("%ds" %lenTitle, f.read(lenTitle))
            
            #mpSpec = {}    
            for _ in tqdm.tqdm(range(nSpec)):
                scan_no, = struct.unpack("i",f.read(4))
                nPeak, = struct.unpack("i", f.read(4))
                peaks = []
                mz_int = struct.unpack(str(nPeak*2)+"d", f.read(nPeak*2*8))
                for i_peak in range(nPeak):
                    mz = mz_int[i_peak*2]
                    inten = mz_int[i_peak*2 + 1]
                    peaks.append( (mz, inten) )
                
                max_inten=0
                if len(peaks)!=0:
                    max_inten=max(peaks,key=lambda x:x[1])[1]
                
                nMix, = struct.unpack("i", f.read(4))
                nMaxCharge = 0
                for i_mix in range(nMix):
                    precursor, = struct.unpack("d", f.read(8))
                    nCharge, = struct.unpack("i", f.read(4))
                    if nCharge > nMaxCharge: nMaxCharge = nCharge
                    specname = f"{spec_title}.{scan_no}.{scan_no}.{nCharge}.{i_mix}.dta"
                    spec_info = (specname, nCharge, precursor, max_inten)
                    yield spec_info, peaks
    

def load_whole_mgf(path_list, transform_peaks=True):
    '''
    Return a dict for all experimental spectra from .mgf text file
    By default if @transform_peaks=True, mz and intensity arrays will be converted to float; otherwise they will be kept as a string.
    '''

    mpSpec = {}  
    for path in path_list:
        with open(path, "r") as f:          
            while True:
                # Go to the next "BEGIN IONS"
                line = f.readline()
                if not line: # EOF
                    break
                while not "BEGIN IONS" in line:
                    line = f.readline()
                    if not line: # EOF
                        break
                if not line:
                    break
                
                # Parse spec headers
                line = f.readline()
                spec_info = dict()
                while "=" in line:
                    line = re.split("=|\n", line)
                    spec_info[line[0]] = line[1]
                    line = f.readline()

                # Parse mz and intensity arrays
                if transform_peaks:
                    peaks = []
                    while not 'END IONS' in line:
                        line = re.split("\s|\n", line)
                        peaks.append( (float(line[0]), float(line[1])) )
                        line = f.readline()
                else:
                    peaks = ""
                    while not 'END IONS' in line:
                        peaks += line
                        line = f.readline()
                mpSpec[spec_info["TITLE"]] = [spec_info, peaks]
    return mpSpec
    
    
def mgf_loader(path_list, transform_peaks=True):
    '''
    Return a generator for experimental spectra from .mgf text file
    By default if @transform_peaks=True, mz and intensity arrays will be converted to float; otherwise they will be kept as a string.
    '''

    for path in path_list:
        with open(path, "r") as f:
            while True:
                # Go to the next "BEGIN IONS"
                line = f.readline()
                if not line: # EOF
                    break
                while not "BEGIN IONS" in line:
                    line = f.readline()
                    if not line: # EOF
                        break
                if not line:
                    break
                
                # Parse spec headers
                line = f.readline()
                spec_info = dict()
                while "=" in line:
                    line = re.split("=|\n", line)
                    spec_info[line[0]] = line[1]
                    line = f.readline()
                
                # Parse mz and intensity arrays
                if transform_peaks:
                    peaks = []
                    while not 'END IONS' in line:
                        line = re.split("\s|\n", line)
                        peaks.append( (float(line[0]), float(line[1])) )
                        line = f.readline()
                else:
                    peaks = ""
                    while not 'END IONS' in line:
                        peaks += line
                        line = f.readline()
                yield spec_info, peaks
